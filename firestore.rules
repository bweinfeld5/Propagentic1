rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // üîê Auth & Role Helpers
    function isSignedIn() {
      return request.auth != null;
    }

    function getRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType;
    }

    // NEW: Development/debugging mode function
    function isDevMode() {
      // Replace with your specific development condition - like IP range, header, etc.
      // For now, we'll create a simple flag that you can set in your app
      return request.auth != null && (request.auth.token.email.matches('.*@propagentic.com$') ||
                                    request.auth.token.email.matches('.*@example.com$'));
    }

    function isLandlord() { 
      return isSignedIn() && 
        (getRole() == 'landlord' || 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'landlord'); 
    }
    function isTenant() { 
      return isSignedIn() && 
        (getRole() == 'tenant' || 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'tenant'); 
    }
    function isContractor() { 
      return isSignedIn() && 
        (getRole() == 'contractor' || 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'contractor'); 
    }
    function isAdmin() { return isSignedIn() && getRole() == 'admin'; }
    function isOwner(userId) { return isSignedIn() && request.auth.uid == userId; }

    function isPropertyOwner(propertyId) {
      let prop = get(/databases/$(database)/documents/properties/$(propertyId));
      return prop.data.landlordId == request.auth.uid;
    }

    function isPropertyTenant(propertyId) {
      let propDoc = get(/databases/$(database)/documents/properties/$(propertyId));
      return (propDoc.data.containsKey('tenants') && propDoc.data.tenants is list && request.auth.uid in propDoc.data.tenants) || 
             (propDoc.data.containsKey('tenantId') && propDoc.data.tenantId == request.auth.uid);
    }

    function isValidString(field, max) {
      return field is string && field.size() <= max;
    }

    function isValidStringArray(arr, maxEntries, maxLength) {
      return arr is list && arr.size() <= maxEntries && 
             (arr.size() == 0 || isArrayOfStringsWithinLength(arr, maxLength));
    }

    function isArrayOfStringsWithinLength(arr, maxLength) {
      // Limit to checking first 10 items (practical limit for validation)
      return (arr.size() >= 1 ? (arr[0] is string && arr[0].size() <= maxLength) : true) &&
             (arr.size() >= 2 ? (arr[1] is string && arr[1].size() <= maxLength) : true) &&
             (arr.size() >= 3 ? (arr[2] is string && arr[2].size() <= maxLength) : true) &&
             (arr.size() >= 4 ? (arr[3] is string && arr[3].size() <= maxLength) : true) &&
             (arr.size() >= 5 ? (arr[4] is string && arr[4].size() <= maxLength) : true) &&
             (arr.size() >= 6 ? (arr[5] is string && arr[5].size() <= maxLength) : true) &&
             (arr.size() >= 7 ? (arr[6] is string && arr[6].size() <= maxLength) : true) &&
             (arr.size() >= 8 ? (arr[7] is string && arr[7].size() <= maxLength) : true) &&
             (arr.size() >= 9 ? (arr[8] is string && arr[8].size() <= maxLength) : true) &&
             (arr.size() >= 10 ? (arr[9] is string && arr[9].size() <= maxLength) : true);
    }

    // --- Maintenance Ticket (existing /tickets) Validation ---
    function isAllowedTicketStatus(status) {
      return status in ['new', 'pending_classification', 'classified', 'pending_assignment', 'assigned', 'in_progress', 'pending_review', 'completed', 'rejected', 'cancelled', 'on_hold', 'escalated'];
    }

    function isAllowedUrgencyLevel(level) {
      return level in ['low', 'medium', 'high', 'critical'];
    }

    function isAllowedIssueType(type) {
      return type in [
        'plumbing_leak', 'plumbing_clog', 'plumbing_no_hot_water', 'plumbing_toilet', 'plumbing_other',
        'electrical_outlet', 'electrical_light', 'electrical_panel', 'electrical_other',
        'hvac_no_heat', 'hvac_no_ac', 'hvac_thermostat', 'hvac_noise', 'hvac_other',
        'appliance_refrigerator', 'appliance_oven', 'appliance_dishwasher', 'appliance_washer_dryer', 'appliance_other',
        'structural_door', 'structural_window', 'structural_wall_ceiling', 'structural_roof', 'structural_other',
        'pest_control_rodents', 'pest_control_insects', 'pest_control_other',
        'landscaping_general', 'landscaping_irrigation',
        'safety_smoke_detector', 'safety_co_detector', 'safety_lock',
        'general_cleaning', 'general_other'
      ];
    }

    function isValidCreateTicketData(data, request) {
      return data.containsKey('propertyId') && data.propertyId is string && data.propertyId.size() > 0 &&
             data.containsKey('tenantId') && data.tenantId == request.auth.uid && // Ensure tenantId matches creator
             data.containsKey('issueType') && isAllowedIssueType(data.issueType) &&
             data.containsKey('description') && data.description is string && data.description.size() > 0 && data.description.size() <= 1000 &&
             data.containsKey('urgencyLevel') && isAllowedUrgencyLevel(data.urgencyLevel) &&
             (!data.containsKey('photos') || (data.photos is list && data.photos.size() <= 10 && (data.photos.size() == 0 || data.photos[0] is string))) && 
             // Ensure client doesn't set system fields on create
             !data.containsKey('status') && 
             !data.containsKey('createdAt') && 
             !data.containsKey('updatedAt') &&
             !data.containsKey('ticketId') && // id is set by Firestore
             !data.containsKey('contractorId') &&
             !data.containsKey('timeline') &&
             !data.containsKey('feedback');
    }
    
    // Deprecated isValidTicket function (commented out in original proposed change)
    // function isValidTicket(data) { ... }

    function isLimitedUpdate(data, resourceData) {
      let allowed = ['status', 'progressUpdates', 'updatedAt'];
      return data.diff(resourceData).affectedKeys().hasOnly(allowed);
    }

    function isValidFeedback(data) {
      return data.rating >= 1 && data.rating <= 5 && isValidString(data.comment, 500);
    }

    // --- Invite Validation (new /invites) ---
    function isAllowedInviteStatus(status) {
      return status in ['pending', 'accepted', 'declined', 'revoked', 'expired'];
    }

    function isValidEmail(email) {
      return email is string && email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    function isValidCreateInviteData(data, request) {
      return data.containsKey('tenantEmail') && isValidEmail(data.tenantEmail) &&
             data.containsKey('propertyId') && data.propertyId is string && data.propertyId.size() > 0 &&
             data.containsKey('landlordId') && data.landlordId == request.auth.uid &&
             (!data.containsKey('propertyName') || (data.propertyName is string && data.propertyName.size() <= 100)) &&
             (!data.containsKey('landlordName') || (data.landlordName is string && data.landlordName.size() <= 100)) &&
             (!data.containsKey('unitNumber') || (data.unitNumber is string && data.unitNumber.size() <= 20)) &&
             !data.containsKey('status') &&
             !data.containsKey('createdAt') &&
             !data.containsKey('expiresAt') &&
             !data.containsKey('id') &&
             !data.containsKey('inviteId') && // inviteId is Firestore doc ID
             !data.containsKey('tenantId') && // tenantId is set on accept
             !data.containsKey('acceptedAt'); // acceptedAt is set on accept
    }

    // MATCHES BEGIN HERE
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin() || isDevMode();
      allow create: if isOwner(userId) || isDevMode();
      allow update: if isOwner(userId) || isDevMode() ||
        (!('role' in request.resource.data) || request.resource.data.role == resource.data.role) &&
        (!('userType' in request.resource.data) || request.resource.data.userType == resource.data.userType);
    }

    match /landlordProfiles/{landlordId} {
      allow read: if isOwner(landlordId) || isAdmin();
      allow create, update: if isOwner(landlordId) && isLandlord();

      match /contractors/{contractorId} {
        allow read: if isOwner(landlordId) || isOwner(contractorId) || isAdmin();
        allow write: if isOwner(landlordId);
      }
    }

    match /contractorProfiles/{contractorId} {
      allow read: if isSignedIn();
      allow create: if isOwner(contractorId) && isContractor();
      allow update: if isOwner(contractorId) &&
        !('averageRating' in request.resource.data) &&
        !('totalRatings' in request.resource.data) &&
        !('totalRatingSum' in request.resource.data) ||
        isAdmin();
    }

    match /tenantProfiles/{tenantId} {
      allow read: if isOwner(tenantId) || isAdmin();
      allow create: if isOwner(tenantId) && isTenant() && request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(tenantId);
    }

    match /properties/{propertyId} {
      allow read: if isSignedIn() && (
        isPropertyOwner(propertyId) || 
        isPropertyTenant(propertyId) || 
        isAdmin() ||
        isLandlord() || // Allow any landlord to read any property for debugging
        isDevMode()
      );
      allow create: if (isLandlord() && request.resource.data.landlordId == request.auth.uid) || isDevMode();
      allow update, delete: if isPropertyOwner(propertyId) || isDevMode();

      match /tenants/{tenantId} {
        allow read: if isPropertyOwner(propertyId) || isOwner(tenantId) || isAdmin() || isDevMode();
        allow write: if isPropertyOwner(propertyId) || isDevMode();
      }
    }

    // Add a specific rule for the tenants collection (if it exists at the root level)
    match /tenants/{tenantId} {
      allow read: if isSignedIn() && (
        isOwner(tenantId) ||
        isLandlord() || // Let landlords read tenant data
        isAdmin() ||
        isDevMode()
      );
      allow write: if isLandlord() || isOwner(tenantId) || isAdmin() || isDevMode();
    }

    match /tickets/{ticketId} {
      allow read: if isSignedIn() && (
        resource.data.tenantId == request.auth.uid ||
        isPropertyOwner(resource.data.propertyId) ||
        (resource.data.containsKey('contractorId') && resource.data.contractorId == request.auth.uid) ||
        isAdmin() ||
        isLandlord() || // Allow any landlord to read any ticket
        isDevMode()
      );

      allow create: if isTenant() &&
        isPropertyTenant(request.resource.data.propertyId) &&
        isValidCreateTicketData(request.resource.data, request); 

      allow update: if isSignedIn() && (
        (
          isPropertyOwner(resource.data.propertyId) &&
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'contractorId', 'notes', 'timeline', 'updatedAt', 'urgencyLevel', 'issueType'])) &&
          (request.resource.data.containsKey('status') ? isAllowedTicketStatus(request.resource.data.status) : true) &&
          (request.resource.data.containsKey('urgencyLevel') ? isAllowedUrgencyLevel(request.resource.data.urgencyLevel) : true) &&
          (request.resource.data.containsKey('issueType') ? isAllowedIssueType(request.resource.data.issueType) : true)
        ) ||
        (
          resource.data.containsKey('contractorId') && resource.data.contractorId == request.auth.uid && isContractor() &&
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'timeline', 'photos', 'notes', 'updatedAt'])) &&
          (request.resource.data.containsKey('status') ? isAllowedTicketStatus(request.resource.data.status) : true)
        ) ||
        (
          resource.data.tenantId == request.auth.uid && isTenant() &&
          ( (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['comments', 'additionalPhotos', 'updatedAt'])) || 
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']) && request.resource.data.status == 'cancelled' && resource.data.status in ['new', 'pending_classification', 'classified']) )
        ) ||
        isAdmin()
      );

      match /feedback/{userId} {
        allow read: if
          get(/databases/$(database)/documents/tickets/$(ticketId)).data.tenantId == request.auth.uid ||
          isPropertyOwner(get(/databases/$(database)/documents/tickets/$(ticketId)).data.propertyId) ||
          (get(/databases/$(database)/documents/tickets/$(ticketId)).data.containsKey('contractorId') && 
           get(/databases/$(database)/documents/tickets/$(ticketId)).data.contractorId == request.auth.uid) ||
          isAdmin();

        allow create: if
          get(/databases/$(database)/documents/tickets/$(ticketId)).data.tenantId == request.auth.uid &&
          request.resource.data.tenantId == request.auth.uid &&
          isValidFeedback(request.resource.data);

        allow update, delete: if false;
      }
    }

    match /notifications/{notificationId} {
      allow read, update, delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid;
      allow create: if isAdmin();
    }

    // Invite Code Rules - Add after the other collection rules
    match /inviteCodes/{codeId} {
      // Define rate limiting for invite code access
      function rateLimitInviteCodeAccess() {
        return request.time.toMillis() - 
          (getAfter(/databases/$(database)/documents/users/$(request.auth.uid)/metadata/rateLimit).data.lastInviteCodeAccess || 0)
          > 5000; // 5 seconds between attempts for rate limiting
      }
      
      // Allow reading invite codes if:
      // 1. The user is authenticated
      // 2. They're either the landlord who created the code OR they're validating a code they possess
      allow get: if request.auth != null && 
        (resource.data.landlordId == request.auth.uid || 
         resource.data.code == request.query.code);
      
      // Allow creating invite codes if:
      // 1. The user is authenticated
      // 2. The user is the landlord specified in the code
      // 3. Required fields are present
      allow create: if request.auth != null && 
        request.resource.data.landlordId == request.auth.uid &&
        request.resource.data.code is string && 
        request.resource.data.propertyId is string;
      
      // Allow listing a landlord's invite codes if:
      // 1. The user is authenticated
      // 2. They're querying for their own landlordId
      allow list: if request.auth != null &&
        request.query.limit <= 20 &&
        request.query.where("landlordId", "==", request.auth.uid) != null;
      
      // Only allow updating invite codes for marking them as used
      // with an atomicity check to prevent race conditions
      allow update: if request.auth != null &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(["used", "usedBy", "usedAt"]) &&
        request.resource.data.usedBy == request.auth.uid &&
        !resource.data.used; // Cannot update an already used code
    }

    match /invites/{inviteId} {
      allow read: if isSignedIn() && (
        resource.data.landlordId == request.auth.uid ||
        (resource.data.containsKey('tenantEmail') && resource.data.tenantEmail == request.auth.token.email) || 
        isAdmin()
      );

      allow list: if isSignedIn() && (
        (isLandlord() && request.query.filters[0][0] == 'landlordId' && request.query.filters[0][2] == request.auth.uid) ||
        // TEMPORARY SIMPLIFIED RULE FOR TENANT TESTING:
        (isTenant() && request.auth.token.email != null) || 
        isAdmin()
      );

      allow create: if isLandlord() &&
        request.resource.data.landlordId == request.auth.uid &&
        isValidCreateInviteData(request.resource.data, request) &&
        request.resource.data.status == 'pending' &&
        request.resource.data.createdAt == request.time &&
        request.resource.data.containsKey('expiresAt');

      allow update: if isSignedIn() && (
        (
          isTenant() &&
          (resource.data.tenantEmail == request.auth.token.email) &&
          resource.data.status == 'pending' && 
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'acceptedAt', 'tenantId', 'updatedAt']) &&
          (request.resource.data.status == 'accepted' ?
            (isAllowedInviteStatus(request.resource.data.status) && 
             request.resource.data.acceptedAt == request.time && 
             request.resource.data.tenantId == request.auth.uid &&
             request.resource.data.updatedAt == request.time) : 
           (request.resource.data.status == 'declined' ? 
             (isAllowedInviteStatus(request.resource.data.status) && 
              !request.resource.data.containsKey('acceptedAt') && 
              !request.resource.data.containsKey('tenantId') &&
              request.resource.data.updatedAt == request.time) : 
            false)
          )
        ) ||
        (
          isLandlord() && resource.data.landlordId == request.auth.uid &&
          resource.data.status == 'pending' && 
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']) &&
          request.resource.data.status == 'revoked' &&
          request.resource.data.updatedAt == request.time
        ) ||
        isAdmin()
      );

      allow delete: if isSignedIn() && (
        (isLandlord() && resource.data.landlordId == request.auth.uid && resource.data.status != 'accepted') ||
        (isTenant() && resource.data.tenantEmail == request.auth.token.email && resource.data.status == 'declined') ||
        isAdmin()
      );
    }

    // Default fallback
    match /{document=**} {
      allow read, write: if isDevMode();
      allow read, write: if false;
    }
  }
}
