rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- UTILITY FUNCTIONS ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isUserRole(role) {
      // Check both 'userType' and 'role' fields for broader compatibility
      let userData = getUserData();
      return isSignedIn() && (userData.userType == role || userData.role == role);
    }

    function isLandlord() { 
      return isUserRole('landlord');
    }
    
    function isTenant() { 
      return isUserRole('tenant');
    }

    function isPropertyOwner(propertyId) {
      let property = get(/databases/$(database)/documents/properties/$(propertyId)).data;
      return isSignedIn() && request.auth.uid == property.landlordId;
    }

    function isPropertyManager(propertyId) {
      let property = get(/databases/$(database)/documents/properties/$(propertyId)).data;
      // Check if a 'managers' field exists and the user's UID is in it.
      return isSignedIn() && property.keys().hasAny(['managers']) && request.auth.uid in property.managers;
    }

    function isPropertyTenant(propertyId) {
      let userData = getUserData();
      // Check both direct propertyId and properties array
      return isTenant() && 
             (userData.propertyId == propertyId || 
              (userData.properties != null && propertyId in userData.properties));
    }

    function isAdmin() {
      return isUserRole('admin');
    }

    // --- DATA VALIDATION FUNCTIONS ---
    function isValidEmail(email) {
      return email is string && email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$');
    }
    
    function isValidInviteCreate() {
      let data = request.resource.data;
      return isLandlord() &&
             data.landlordId == request.auth.uid &&
             isPropertyOwner(data.propertyId) &&
             isValidEmail(data.tenantEmail) &&
             data.status == 'pending' &&
             data.createdAt == request.time &&
             data.keys().hasAll(['landlordId', 'propertyId', 'tenantEmail', 'status', 'createdAt']);
    }

    function isValidInviteUpdate() {
      let data = request.resource.data;
      let existingData = resource.data;
      // Tenant accepting the invite
      return (isTenant() && 
              data.status == 'accepted' && 
              data.tenantId == request.auth.uid &&
              existingData.tenantEmail == getUserData().email) ||
             // Landlord revoking the invite
             (isLandlord() &&
              isPropertyOwner(existingData.propertyId) &&
              data.status == 'revoked');
    }

    function isValidPropertyCreate() {
      let data = request.resource.data;
      return isLandlord() &&
             data.landlordId == request.auth.uid &&
             data.keys().hasAll(['landlordId', 'streetAddress', 'city', 'state', 'zipCode', 'propertyType']);
    }
    
    function isValidTicketCreate() {
      let data = request.resource.data;
      return isTenant() &&
             data.submittedBy == request.auth.uid &&
             isPropertyTenant(data.propertyId) &&
             data.keys().hasAll(['submittedBy', 'propertyId', 'category', 'description', 'priority']);
    }

    // --- RULES ---

    // Users Collection
    match /users/{userId} {
      allow read, update: if isOwner(userId) || isAdmin();
      allow create: if isSignedIn();
    }

    // Properties Collection
    match /properties/{propertyId} {
      allow read: if isSignedIn() && ((isLandlord() && resource.data.landlordId == request.auth.uid) || isPropertyManager(propertyId) || isPropertyTenant(propertyId) || isAdmin());
      allow create: if isSignedIn() && (isLandlord() || isAdmin());
      allow update: if isSignedIn() && (isPropertyOwner(propertyId) || isPropertyManager(propertyId) || isAdmin());
      allow delete: if isSignedIn() && (isPropertyOwner(propertyId) || isAdmin());
    }

    // Tickets Collection
    match /tickets/{ticketId} {
      let ticket = get(/databases/$(database)/documents/tickets/$(ticketId)).data;
      // Submitted by user, or owner/manager of the property can read/update.
      allow read, update: if isSignedIn() && (isOwner(ticket.submittedBy) || isPropertyOwner(ticket.propertyId) || isPropertyManager(ticket.propertyId) || isAdmin());
      // Any signed-in user can create a ticket.
      allow create: if isSignedIn(); 
    }

    // Invites Collection
    match /invites/{inviteId} {
      // Landlords and admins can manage invites.
      allow create: if isLandlord() || isAdmin();
      allow read, update: if (isLandlord() && resource.data.landlordId == request.auth.uid) ||
                             (isSignedIn() && resource.data.tenantEmail == request.auth.token.email) ||
                             isAdmin();
      allow delete: if (isLandlord() && resource.data.landlordId == request.auth.uid) || isAdmin();
    }

    // New rule for invite codes, allows any authenticated user to read (for validation)
    match /inviteCodes/{code} {
        allow read: if isSignedIn();
        // Only cloud functions can create/write codes
        allow write: if false;
    }

    // Generic mail collection for triggering emails
    match /mail/{mailId} {
      allow create: if isSignedIn(); // Allow any signed-in user to create an email document
    }
  }
}
