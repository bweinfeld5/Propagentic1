rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- UTILITY FUNCTIONS ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isUserRole(role) {
      // Check both 'userType' and 'role' fields for broader compatibility
      let userData = getUserData();
      return isSignedIn() && (userData.userType == role || userData.role == role);
    }

    function isLandlord() { 
      return isUserRole('landlord');
    }
    
    function isTenant() { 
      return isUserRole('tenant');
    }

    function isPropertyOwner(propertyId) {
      let property = get(/databases/$(database)/documents/properties/$(propertyId)).data;
      return isSignedIn() && request.auth.uid == property.landlordId;
    }

    function isPropertyManager(propertyId) {
      let property = get(/databases/$(database)/documents/properties/$(propertyId)).data;
      // Check if a 'managers' field exists and the user's UID is in it.
      return isSignedIn() && property.keys().hasAny(['managers']) && request.auth.uid in property.managers;
    }

    function isPropertyTenant(propertyId) {
      let userData = getUserData();
      // Check both direct propertyId and properties array
      return isTenant() && 
             (userData.propertyId == propertyId || 
              (userData.properties != null && propertyId in userData.properties));
    }

    function isContractor() {
      return isUserRole('contractor');
    }

    function isAdmin() {
      return isUserRole('admin');
    }

    function isContractorInLandlordRolodex(landlordId, contractorId) {
      let landlordProfile = get(/databases/$(database)/documents/landlordProfiles/$(landlordId)).data;
      return landlordProfile.contractors != null && contractorId in landlordProfile.contractors;
    }



    // --- DATA VALIDATION FUNCTIONS ---
    function isValidEmail(email) {
      return email is string && email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$');
    }
    
    function isValidInviteCreate() {
      let data = request.resource.data;
      return isLandlord() &&
             data.landlordId == request.auth.uid &&
             isPropertyOwner(data.propertyId) &&
             isValidEmail(data.tenantEmail) &&
             data.status == 'pending' &&
             data.createdAt == request.time &&
             data.keys().hasAll(['landlordId', 'propertyId', 'tenantEmail', 'status', 'createdAt']);
    }

    function isValidInviteUpdate() {
      let data = request.resource.data;
      let existingData = resource.data;
      // Tenant accepting the invite
      return (isTenant() && 
              data.status == 'accepted' && 
              data.tenantId == request.auth.uid &&
              existingData.tenantEmail == getUserData().email) ||
             // Landlord revoking the invite
             (isLandlord() &&
              isPropertyOwner(existingData.propertyId) &&
              data.status == 'revoked');
    }

    function isValidPropertyCreate() {
      let data = request.resource.data;
      return isLandlord() &&
             data.landlordId == request.auth.uid &&
             data.keys().hasAll(['landlordId', 'streetAddress', 'city', 'state', 'zipCode', 'propertyType']);
    }
    
    function isValidTicketCreate() {
      let data = request.resource.data;
      return isTenant() &&
             data.submittedBy == request.auth.uid &&
             isPropertyTenant(data.propertyId) &&
             data.keys().hasAll(['submittedBy', 'propertyId', 'category', 'description', 'priority']);
    }

    // --- RULES ---

    // Users Collection
    match /users/{userId} {
      allow read, update: if isOwner(userId) || isAdmin();
      allow create: if isSignedIn();
    }

    // Tenant Profiles Collection
    match /tenantProfiles/{tenantId} {
      // Tenants can read/update their own profile, landlords can read their tenants' profiles, admins can access all
      allow read: if isOwner(tenantId) || 
                     (isLandlord() && resource.data.landlordId == request.auth.uid) ||
                     isAdmin();
      allow create: if isOwner(tenantId) && isTenant();
      allow update: if isOwner(tenantId) || 
                       (isLandlord() && resource.data.landlordId == request.auth.uid) ||
                       isAdmin();
      allow delete: if isOwner(tenantId) || isAdmin();
    }

    // Contractor Profiles Collection - CRITICAL SECURITY FIX
    match /contractorProfiles/{contractorId} {
      // Contractors can read/update their own profile
      // Landlords can read contractor profiles in their rolodex
      // Admins can access all contractor profiles
      allow read: if isOwner(contractorId) || 
                     isLandlord() ||
                     isAdmin();
      allow create: if isOwner(contractorId) && isContractor();
      allow update: if isOwner(contractorId) || isAdmin();
      allow delete: if isOwner(contractorId) || isAdmin();
    }

    // Landlord Profiles Collection
    match /landlordProfiles/{landlordId} {
      // Landlords can read/update their own profile
      // Contractors can read profiles of landlords who have them in their rolodex
      // Admins can access all
      allow read: if isOwner(landlordId) ||
                     (isContractor() && isContractorInLandlordRolodex(landlordId, request.auth.uid)) ||
                     isAdmin();
      allow create: if isOwner(landlordId) && isLandlord();
      allow update: if isOwner(landlordId) || isAdmin();
      allow delete: if isOwner(landlordId) || isAdmin();
    }

    // Properties Collection
    match /properties/{propertyId} {
      // Allow individual document reads for property owners, managers, tenants, and admins
      allow get: if isSignedIn() && ((isLandlord() && resource.data.landlordId == request.auth.uid) || isPropertyManager(propertyId) || isPropertyTenant(propertyId) || isAdmin());
      // Allow listing properties for landlords (they can query their own properties)
      allow list: if isSignedIn() && (isLandlord() || isAdmin());
      allow create: if isSignedIn() && (isLandlord() || isAdmin());
      allow update: if isSignedIn() && (isPropertyOwner(propertyId) || isPropertyManager(propertyId) || isAdmin());
      allow delete: if isSignedIn() && (isPropertyOwner(propertyId) || isAdmin());
    }

    // Tickets Collection
    match /tickets/{ticketId} {
      // Submitted by user, property owner/manager, assigned contractor, or admin can read/update
      allow read, update: if isSignedIn() && (
        isOwner(resource.data.submittedBy) || 
        isPropertyOwner(resource.data.propertyId) || 
        isPropertyManager(resource.data.propertyId) ||
        (isContractor() && resource.data.contractorId == request.auth.uid) ||
        isAdmin()
      );
      // Any signed-in user can create a ticket
      allow create: if isSignedIn(); 
    }

    // Invites Collection
    match /invites/{inviteId} {
      // Landlords and admins can manage invites.
      allow create: if isLandlord() || isAdmin();
      allow read, update: if (isLandlord() && resource.data.landlordId == request.auth.uid) ||
                             (isSignedIn() && resource.data.tenantEmail == request.auth.token.email) ||
                             isAdmin();
      allow delete: if (isLandlord() && resource.data.landlordId == request.auth.uid) || isAdmin();
    }

    // New rule for invite codes, allows any authenticated user to read (for validation)
    match /inviteCodes/{code} {
        allow read: if isSignedIn();
        // Only cloud functions can create/write codes
        allow write: if false;
    }

    // Generic mail collection for triggering emails
    match /mail/{mailId} {
      allow create: if isSignedIn(); // Allow any signed-in user to create an email document
      allow read: if isSignedIn(); // Allow read access for testing email system functionality
    }

    // Property Invitations Collection - for tenant property invitations
    match /propertyInvitations/{invitationId} {
      // Landlords can create invitations for their properties
      allow create: if isLandlord() && isPropertyOwner(request.resource.data.propertyId);
      // Invited tenants can read their own invitations via email match
      allow read: if isSignedIn() && (
        (isLandlord() && isPropertyOwner(resource.data.propertyId)) ||
        (isTenant() && resource.data.tenantEmail == request.auth.token.email) ||
        isAdmin()
      );
      // Tenants can update to accept/decline, landlords can update their own invitations
      allow update: if isSignedIn() && (
        (isLandlord() && isPropertyOwner(resource.data.propertyId)) ||
        (isTenant() && resource.data.tenantEmail == request.auth.token.email) ||
        isAdmin()
      );
      // Landlords can delete their own invitations
      allow delete: if isSignedIn() && (
        (isLandlord() && isPropertyOwner(resource.data.propertyId)) ||
        isAdmin()
      );
    }

    // Notifications Collection
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      // Only cloud functions can create notifications
      allow create: if false;
      // Users can update their own notifications (mark as read, etc.)
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      // Users can delete their own notifications
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Jobs Collection - for job/work order management
    match /jobs/{jobId} {
      // Property owners, assigned contractors, and admins can access jobs
      allow read, update: if isSignedIn() && (
        isPropertyOwner(resource.data.propertyId) ||
        (isContractor() && resource.data.contractorId == request.auth.uid) ||
        isAdmin()
      );
      // Property owners and admins can create jobs
      allow create: if isSignedIn() && (
        isLandlord() ||
        isAdmin()
      );
      // Property owners and admins can delete jobs
      allow delete: if isSignedIn() && (
        isPropertyOwner(resource.data.propertyId) ||
        isAdmin()
      );
    }

    // Disputes Collection - for handling disputes
    match /disputes/{disputeId} {
      // Involved parties (submitter, contractor, property owner) and admins can access
      allow read, update: if isSignedIn() && (
        resource.data.submittedBy == request.auth.uid ||
        resource.data.contractorId == request.auth.uid ||
        isPropertyOwner(resource.data.propertyId) ||
        isAdmin()
      );
      // Tenants and landlords can create disputes
      allow create: if isSignedIn() && (isTenant() || isLandlord());
      // Only admins can delete disputes
      allow delete: if isAdmin();
    }

    // Escrow Collection - for payment management
    match /escrow/{escrowId} {
      // Property owners, contractors involved, and admins can access
      allow read, update: if isSignedIn() && (
        isPropertyOwner(resource.data.propertyId) ||
        resource.data.contractorId == request.auth.uid ||
        isAdmin()
      );
      // Property owners and admins can create escrow
      allow create: if isSignedIn() && (isLandlord() || isAdmin());
      // Only admins can delete escrow records
      allow delete: if isAdmin();
    }

    // Conversations Collection - for real-time messaging
    match /conversations/{conversationId} {
      function isParticipant() {
        return isSignedIn() && request.auth.uid in resource.data.participants;
      }

      function isValidParticipant() {
        return isSignedIn() && 
               request.auth.uid in request.resource.data.participants;
      }

      // Read conversations if user is a participant
      allow read: if isParticipant();
      
      // Create conversations if user is one of the participants
      allow create: if isValidParticipant();
      
      // Update conversations if user is a participant (for marking as read, etc.)
      allow update: if isParticipant();
      
      // Delete conversations if user is a participant
      allow delete: if isParticipant();
    }

    // Messages Collection - for individual messages
    match /messages/{messageId} {
      function isMessageParticipant() {
        let conversation = get(/databases/$(database)/documents/conversations/$(resource.data.conversationId)).data;
        return isSignedIn() && request.auth.uid in conversation.participants;
      }

      function canCreateMessage() {
        let conversation = get(/databases/$(database)/documents/conversations/$(request.resource.data.conversationId)).data;
        return isSignedIn() && 
               request.auth.uid in conversation.participants &&
               request.resource.data.senderId == request.auth.uid;
      }

      // Read messages if user is participant of the conversation
      allow read: if isMessageParticipant();
      
      // Create messages if user is participant and sender matches auth
      allow create: if canCreateMessage();
      
      // Update messages if user is participant (for marking as read, editing)
      allow update: if isMessageParticipant();
      
      // Delete messages if user is the sender
      allow delete: if isSignedIn() && resource.data.senderId == request.auth.uid;
    }

    // Property Tenant Relationships Collection - for associating tenants with properties
    match /propertyTenantRelationships/{relationshipId} {
      // Property owners and tenants involved in the relationship can read/access
      allow read: if isSignedIn() && (
        isPropertyOwner(resource.data.propertyId) ||
        resource.data.tenantId == request.auth.uid ||
        isAdmin()
      );
      // Only cloud functions should create/update relationships (via invite redemption)
      allow write: if false;
    }
  }
}
